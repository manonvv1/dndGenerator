diff --git a/api.go b/api.go
index 6114f42..afcb464 100644
--- a/api.go
+++ b/api.go
@@ -1,3 +1,5 @@
+// ===== Infrastructure Adapter (HTTP client for DnD 2014 API) =====
+
 package main
 
 import (
@@ -8,6 +10,15 @@ import (
 	"strings"
 )
 
+const baseEquipmentURL = "https://www.dnd5eapi.co/api/equipment/"
+
+type EquipmentProvider interface {
+	FetchWeaponMeta(name string) (WeaponMeta, bool)
+	FetchArmorMeta(name string) (ArmorMeta, bool)
+}
+
+var EquipProv EquipmentProvider = &HttpEquipmentAdapter{}
+
 /**
 *  httpGetJSON performs an HTTP GET and decodes JSON response into v
 **/
@@ -29,14 +40,64 @@ func httpGetJSON(url string, v any, tick <-chan time.Time) error {
 	return json.NewDecoder(resp.Body).Decode(v)
 }
 
+type HttpEquipmentAdapter struct{}
+
+func (a *HttpEquipmentAdapter) FetchWeaponMeta(name string) (WeaponMeta, bool) {
+	var eq apiEquipment
+	if err := httpGetJSON(baseEquipmentURL+slugify(name), &eq, nil); err != nil {
+		return WeaponMeta{}, false
+	}
+	wm := WeaponMeta{
+		Category:    eq.EquipmentCategory.Name,
+		RangeNormal: eq.Range.Normal,
+		DamageDice:  eq.Damage.DamageDice,
+		WeaponRange: eq.WeaponRange,
+		TwoHanded:   false,
+		Finesse:     false,
+	}
+	for _, p := range eq.Properties {
+		switch strings.ToLower(p.Index) {
+		case "two-handed":
+			wm.TwoHanded = true
+		case "finesse":
+			wm.Finesse = true
+		}
+	}
+	if wm.RangeNormal == 0 && strings.EqualFold(wm.WeaponRange, "melee") {
+		wm.RangeNormal = 5
+	}
+	return wm, true
+}
+
+func (a *HttpEquipmentAdapter) FetchArmorMeta(name string) (ArmorMeta, bool) {
+	var eq apiEquipment
+	if err := httpGetJSON(baseEquipmentURL+slugify(name), &eq, nil); err != nil {
+		_ = httpGetJSON(baseEquipmentURL+slugify(name+" armor"), &eq, nil)
+	}
+	if eq.ArmorClass.Base == 0 && !eq.ArmorClass.DexBonus && eq.ArmorClass.MaxBonus == nil {
+		return ArmorMeta{}, false
+	}
+	return ArmorMeta{
+		ArmorClass:  eq.ArmorClass.Base,
+		DexBonus:    eq.ArmorClass.DexBonus,
+		MaxDexBonus: eq.ArmorClass.MaxBonus,
+	}, true
+}
+
 
 type apiEquipment struct {
 	EquipmentCategory struct{ Name string `json:"name"` } `json:"equipment_category"`
 	WeaponRange string `json:"weapon_range"`
 	Range       struct{ Normal int `json:"normal"` } `json:"range"`
-	Properties  []struct{ Index, Name string } `json:"properties"`
+	Properties  []struct{
+		Index string `json:"index"`
+		Name  string `json:"name"`
+	} `json:"properties"`
+	Damage struct {
+		DamageDice string `json:"damage_dice"`
+	} `json:"damage"`
 	ArmorClass  struct {
-		Base int `json:"base"`
+		Base     int  `json:"base"`
 		DexBonus bool `json:"dex_bonus"`
 		MaxBonus *int `json:"max_bonus"`
 	} `json:"armor_class"`
@@ -48,33 +109,18 @@ type apiSpell struct {
 }
 
 /**
-*  EnrichCharacter enriches a Character with weapon, armor, and spell data from the D&D  API
+*  EnrichCharacter enriches a Character with weapon, armor, and spell data from the D&D API
 **/
 func EnrichCharacter(c *Character) {
 	if w := strings.TrimSpace(c.Equipment.Weapon); w != "" {
-		var eq apiEquipment
-		if err := httpGetJSON("https://www.dnd5eapi.co/api/equipment/"+slugify(w), &eq, nil); err == nil {
-			c.Equipment.WeaponInfo.Category = eq.EquipmentCategory.Name
-			c.Equipment.WeaponInfo.RangeNormal = eq.Range.Normal
-			two := false
-			for _, p := range eq.Properties {
-				pi := strings.ToLower(p.Index + " " + p.Name)
-				if strings.Contains(pi, "two-handed") { two = true; break }
-			}
-			c.Equipment.WeaponInfo.TwoHanded = two
+		if wm, ok := EquipProv.FetchWeaponMeta(w); ok {
+			c.Equipment.WeaponInfo = wm
 		}
 	}
 
 	if a := strings.TrimSpace(c.Equipment.Armor); a != "" {
-		var eq apiEquipment
-		err := httpGetJSON("https://www.dnd5eapi.co/api/equipment/"+slugify(a), &eq, nil)
-		if err != nil && !strings.Contains(strings.ToLower(a), "armor") {
-			_ = httpGetJSON("https://www.dnd5eapi.co/api/equipment/"+slugify(a+" armor"), &eq, nil)
-		}
-		if eq.ArmorClass.Base != 0 || eq.ArmorClass.DexBonus || eq.ArmorClass.MaxBonus != nil {
-			c.Equipment.ArmorInfo.ArmorClass  = eq.ArmorClass.Base
-			c.Equipment.ArmorInfo.DexBonus    = eq.ArmorClass.DexBonus
-			c.Equipment.ArmorInfo.MaxDexBonus = eq.ArmorClass.MaxBonus
+		if am, ok := EquipProv.FetchArmorMeta(a); ok {
+			c.Equipment.ArmorInfo = am
 		}
 	}
 
@@ -88,4 +134,4 @@ func EnrichCharacter(c *Character) {
 			}
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/combat.go b/combat.go
index e45b433..826cc46 100644
--- a/combat.go
+++ b/combat.go
@@ -1,6 +1,11 @@
+// Layer: Domain (business rules: damage, AC, initiative; no IO)
+
 package main
 
-import "strings"
+import (
+	"strings"
+	// "fmt"
+)
 
 /**
 * DexModOf returns the Dexterity ability modifier
@@ -121,4 +126,11 @@ func computePassivePerception(c *Character) int {
 		pp += c.ProficiencyBonus
 	}
 	return pp
-}
\ No newline at end of file
+}
+
+/**
+* computeWeaponDamageString geeft "XdY + N" of "" als er geen data is
+**/
+func computeWeaponDamageString(c *Character) string {
+    return ""
+}
diff --git a/exam_test.go b/exam_test.go
new file mode 100644
index 0000000..bab2ac6
--- /dev/null
+++ b/exam_test.go
@@ -0,0 +1,52 @@
+package main
+
+import "testing"
+
+func mkChar(str, dex int, dice, wrange string, finesse bool) *Character {
+	return &Character{
+		AbilityScores: AbilityScores{Strength: str, Dexterity: dex},
+		Equipment: Equipment{
+			Weapon: "x",
+			WeaponInfo: WeaponMeta{
+				DamageDice:  dice,
+				WeaponRange: wrange, 
+				Finesse:     finesse,
+			},
+		},
+	}
+}
+
+func TestAbilityMod(t *testing.T) {
+	cases := []struct {
+		score int
+		want  int
+	}{
+		{10, 0}, {11, 0}, {9, -1}, {15, 2}, {17, 3},
+	}
+	for _, tc := range cases {
+		if got := abilityMod(tc.score); got != tc.want {
+			t.Fatalf("abilityMod(%d)=%d; want %d", tc.score, got, tc.want)
+		}
+	}
+}
+
+func TestDamage_Gor(t *testing.T) {
+	c := mkChar(17, 14, "1d12", "Melee", false) 
+	if got, want := computeWeaponDamageString(c), "1d12 + 3"; got != want {
+		t.Fatalf("Gor dmg = %q; want %q", got, want)
+	}
+}
+
+func TestDamage_Nyx(t *testing.T) {
+	c := mkChar(13, 15, "1d6", "Melee", true) 
+	if got, want := computeWeaponDamageString(c), "1d6 + 2"; got != want {
+		t.Fatalf("Nyx dmg = %q; want %q", got, want)
+	}
+}
+
+func TestDamage_Bruni(t *testing.T) {
+	c := mkChar(8, 15, "1d8", "Melee", true) 
+	if got, want := computeWeaponDamageString(c), "1d8 + 2"; got != want {
+		t.Fatalf("Bruni dmg = %q; want %q", got, want)
+	}
+}
diff --git a/main.go b/main.go
index cc40f5d..2d451e9 100644
--- a/main.go
+++ b/main.go
@@ -1,3 +1,4 @@
+// Layer: Infrastructure / UI (CLI commands; invokes application/domain)
 package main
 
 import (
@@ -6,12 +7,16 @@ import (
 	"os"
 	"sort"
 	"strings"
-	"sync"
-	"time"
+)
+
+const (
+	constSpellSlotsLine          = "Spell slots:"
+	constCharNotFoundFmt          = "character \"%s\" not found\n"
+	constSpellTooHighMsg          = "the spell has higher level than the available spell slots"
 )
 
 /**
-*  usage prints command-line help
+* usage prints command-line help
 **/
 func usage() {
 	app := os.Args[0]
@@ -23,686 +28,672 @@ func usage() {
   %s equip -name NAME [-weapon WEAPON] [-armor ARMOR] [-shield SHIELD] [-slot SLOT]
   %s prepare -name NAME -spell "SPELL NAME"
   %s learn -name NAME -spell "SPELL NAME"
-  %s enrich [-limit N] [-dryrun] [-rps N] [-workers N]
+  %s enrich [-limit N] [-dryrun] [-rps N] [-workers N] 
   %s inspect [-name NAME_OR_SUBSTRING]
   %s serve [-addr :8080]
 `, app, app, app, app, app, app, app, app, app, app)
 }
 
-/**
-*  main is the CLI entrypoint for creating, viewing, managing, and enriching characters
-**/
-func main() {
-	loadCharacters()
-	if len(os.Args) < 2 {
-		usage()
-		os.Exit(1)
+
+func upsertCharacter(c Character) {
+	idx := -1
+	for i := range characters {
+		if strings.EqualFold(characters[i].Name, c.Name) {
+			idx = i
+			break
+		}
 	}
-	switch os.Args[1] {
+	if idx >= 0 {
+		characters[idx] = c
+	} else {
+		characters = append(characters, c)
+	}
+}
 
-	case "serve":
-		serveCommand(os.Args[2:])
+func printAbilityScores(c *Character) {
+	fmt.Println("Ability scores:")
+	fmt.Printf("  STR: %d (%+d)\n", c.AbilityScores.Strength, abilityMod(c.AbilityScores.Strength))
+	fmt.Printf("  DEX: %d (%+d)\n", c.AbilityScores.Dexterity, abilityMod(c.AbilityScores.Dexterity))
+	fmt.Printf("  CON: %d (%+d)\n", c.AbilityScores.Constitution, abilityMod(c.AbilityScores.Constitution))
+	fmt.Printf("  INT: %d (%+d)\n", c.AbilityScores.Intelligence, abilityMod(c.AbilityScores.Intelligence))
+	fmt.Printf("  WIS: %d (%+d)\n", c.AbilityScores.Wisdom, abilityMod(c.AbilityScores.Wisdom))
+	fmt.Printf("  CHA: %d (%+d)\n", c.AbilityScores.Charisma, abilityMod(c.AbilityScores.Charisma))
+}
 
-	case "create":
-		fs := flag.NewFlagSet("create", flag.ExitOnError)
-		name := fs.String("name", "", "required")
-		race := fs.String("race", "", "")
-		class := fs.String("class", "", "")
-		level := fs.Int("level", 1, "")
-		bgLong := fs.String("background", "", "optional")
-		bgShort := fs.String("bg", "", "optional")
-		_ = bgLong
-		_ = bgShort
-		bg := "acolyte"
-		str := fs.Int("str", 0, "")
-		dex := fs.Int("dex", 0, "")
-		con := fs.Int("con", 0, "")
-		intl := fs.Int("int", 0, "")
-		wis := fs.Int("wis", 0, "")
-		cha := fs.Int("cha", 0, "")
-		skillsFlag := fs.String("skills", "", "comma separated")
-		_ = fs.Parse(os.Args[2:])
-
-		if *name == "" {
-			fmt.Println("name is required")
-			os.Exit(2)
-		}
-		raw := []int{*str, *dex, *con, *intl, *wis, *cha}
-		providedAll, providedAny := true, false
-		for _, v := range raw {
-			if v != 0 {
-				providedAny = true
-			} else {
-				providedAll = false
-			}
-		}
-		def10 := func(x int) int {
-			if x == 0 {
-				return 10
-			}
-			return x
-		}
+func normalizeSkillList(in []string) []string {
+	out := make([]string, len(in))
+	for i, s := range in {
+		s = strings.ReplaceAll(s, "_", " ")
+		s = strings.ReplaceAll(s, "-", " ")
+		out[i] = strings.ToLower(strings.Join(strings.Fields(s), " "))
+	}
+	sort.Strings(out)
+	return out
+}
+
+func printSpellSlotsBlock(c *Character, keys []int, includeHeader bool) {
+	if includeHeader {
+		fmt.Println(constSpellSlotsLine)
+	}
+	for _, lvl := range keys {
+		fmt.Printf("  Level %d: %d\n", lvl, c.Spellcasting.SlotsByLevel[lvl])
+	}
+}
 
-		var base AbilityScores
-		switch {
-		case providedAll:
-			base = AbilityScores{*str, *dex, *con, *intl, *wis, *cha}
-		case providedAny:
-			base = AbilityScores{def10(*str), def10(*dex), def10(*con), def10(*intl), def10(*wis), def10(*cha)}
-		default:
-			base = assignStandardArray()
+func slotKeys(c *Character, min int) []int {
+	keys := make([]int, 0, len(c.Spellcasting.SlotsByLevel))
+	for lvl := range c.Spellcasting.SlotsByLevel {
+		if lvl >= min {
+			keys = append(keys, lvl)
 		}
+	}
+	sort.Ints(keys)
+	return keys
+}
 
-		rStr, rDex, rCon, rInt, rWis, rCha := raceBonusDeltas(*race)
-		final := AbilityScores{
-			Strength: base.Strength + rStr, Dexterity: base.Dexterity + rDex, Constitution: base.Constitution + rCon,
-			Intelligence: base.Intelligence + rInt, Wisdom: base.Wisdom + rWis, Charisma: base.Charisma + rCha,
+func maxSlotLevel(slots map[int]int) int {
+	max := 0
+	for lvl, count := range slots {
+		if count > 0 && lvl > max {
+			max = lvl
 		}
+	}
+	return max
+}
 
-		if bg == "" {
-			bg = strings.ToLower(strings.TrimSpace(*bgShort))
+
+func calcBaseScoresCLI(str, dex, con, intl, wis, cha int) AbilityScores {
+	raw := []int{str, dex, con, intl, wis, cha}
+	providedAll, providedAny := true, false
+	for _, v := range raw {
+		if v != 0 {
+			providedAny = true
+		} else {
+			providedAll = false
 		}
-		if bg == "" {
-			bg = "acolyte"
+	}
+	def10 := func(x int) int {
+		if x == 0 {
+			return 10
 		}
+		return x
+	}
+	switch {
+	case providedAll:
+		return AbilityScores{str, dex, con, intl, wis, cha}
+	case providedAny:
+		return AbilityScores{def10(str), def10(dex), def10(con), def10(intl), def10(wis), def10(cha)}
+	default:
+		return assignStandardArray()
+	}
+}
 
-		var provided []string
-		if *skillsFlag != "" {
-			for _, p := range strings.Split(*skillsFlag, ",") {
-				if t := strings.TrimSpace(p); t != "" {
-					provided = append(provided, t)
-				}
-			}
-		}
+func applyRaceBonusesCLI(base AbilityScores, race string) AbilityScores {
+	rStr, rDex, rCon, rInt, rWis, rCha := raceBonusDeltas(race)
+	return AbilityScores{
+		Strength:     base.Strength + rStr,
+		Dexterity:    base.Dexterity + rDex,
+		Constitution: base.Constitution + rCon,
+		Intelligence: base.Intelligence + rInt,
+		Wisdom:       base.Wisdom + rWis,
+		Charisma:     base.Charisma + rCha,
+	}
+}
 
-		ct := casterType(*class)
-		var sc *Spellcasting
-		if ct != "none" {
-			slots := spellSlotsFor(ct, *level)
-			maxL := maxSpellLevel(ct, *level)
-			chosen := pickSpellsForClass(*class, maxL, 4)
-			sc = &Spellcasting{SlotsByLevel: slots, Spells: chosen}
+func parseSkillsCSV(s string) []string {
+	if strings.TrimSpace(s) == "" {
+		return nil
+	}
+	var out []string
+	for _, p := range strings.Split(s, ",") {
+		if t := strings.TrimSpace(p); t != "" {
+			out = append(out, t)
 		}
+	}
+	return out
+}
 
-		c := Character{
-			Name: *name, Race: strings.ToLower(*race), Class: strings.ToLower(*class), Level: *level,
-			Background: bg, AbilityScores: final, ProficiencyBonus: profByLevel(*level),
-			Skills: finalSkills(*class, bg, provided), Spellcasting: sc,
-		}
-		characters = append(characters, c)
-		saveCharacters()
-		fmt.Printf("saved character %s\n", c.Name)
+func buildSpellcastingCLI(class string, level int) *Spellcasting {
+	ct := casterType(class)
+	if ct == "none" {
+		return nil
+	}
+	slots := spellSlotsFor(ct, level)
+	maxL := maxSpellLevel(ct, level)
+	chosen := pickSpellsForClass(class, maxL, 4)
+	return &Spellcasting{SlotsByLevel: slots, Spells: chosen}
+}
 
-	case "view":
-		fs := flag.NewFlagSet("view", flag.ExitOnError)
-		name := fs.String("name", "", "required")
-		noSlots := fs.Bool("no-slots", false, "hide spell slot lines")
+func cmdCreate(args []string) {
+	fs := flag.NewFlagSet("create", flag.ExitOnError)
+	name := fs.String("name", "", "required")
+	race := fs.String("race", "", "")
+	class := fs.String("class", "", "")
+	level := fs.Int("level", 1, "")
+	bgLong := fs.String("background", "", "optional")
+	bgShort := fs.String("bg", "", "optional")
+	_ = bgLong
+	_ = bgShort
+
+	str := fs.Int("str", 0, "")
+	dex := fs.Int("dex", 0, "")
+	con := fs.Int("con", 0, "")
+	intl := fs.Int("int", 0, "")
+	wis := fs.Int("wis", 0, "")
+	cha := fs.Int("cha", 0, "")
+	skillsFlag := fs.String("skills", "", "comma separated")
+	_ = fs.Parse(args)
+
+	if *name == "" {
+		fmt.Println("name is required")
+		os.Exit(2)
+	}
 
-		_ = fs.Parse(os.Args[2:])
+	base := calcBaseScoresCLI(*str, *dex, *con, *intl, *wis, *cha)
+	final := applyRaceBonusesCLI(base, *race)
 
-		c := findCharLike(*name)
-		if c == nil {
-			fmt.Printf("character \"%s\" not found\n", *name)
-			return
-		}
+	bg := "acolyte"
 
-		fmt.Printf("Name: %s\n", c.Name)
-		fmt.Printf("Class: %s\n", strings.ToLower(c.Class))
-		fmt.Printf("Race: %s\n", strings.ToLower(c.Race))
-		fmt.Printf("Background: %s\n", strings.ToLower(strings.TrimSpace(c.Background)))
-		fmt.Printf("Level: %d\n", c.Level)
-		fmt.Println("Ability scores:")
-		fmt.Printf("  STR: %d (%+d)\n", c.AbilityScores.Strength, abilityMod(c.AbilityScores.Strength))
-		fmt.Printf("  DEX: %d (%+d)\n", c.AbilityScores.Dexterity, abilityMod(c.AbilityScores.Dexterity))
-		fmt.Printf("  CON: %d (%+d)\n", c.AbilityScores.Constitution, abilityMod(c.AbilityScores.Constitution))
-		fmt.Printf("  INT: %d (%+d)\n", c.AbilityScores.Intelligence, abilityMod(c.AbilityScores.Intelligence))
-		fmt.Printf("  WIS: %d (%+d)\n", c.AbilityScores.Wisdom, abilityMod(c.AbilityScores.Wisdom))
-		fmt.Printf("  CHA: %d (%+d)\n", c.AbilityScores.Charisma, abilityMod(c.AbilityScores.Charisma))
-		fmt.Printf("Proficiency bonus: %+d\n", c.ProficiencyBonus)
-
-		skillsOut := make([]string, len(c.Skills))
-		for i, s := range c.Skills {
-			s = strings.ReplaceAll(s, "_", " ")
-			s = strings.ReplaceAll(s, "-", " ")
-			s = strings.Join(strings.Fields(s), " ")
-			skillsOut[i] = strings.ToLower(s)
-		}
-		sort.Strings(skillsOut)
-		fmt.Printf("Skill proficiencies: %s\n", strings.Join(skillsOut, ", "))
+	provided := parseSkillsCSV(*skillsFlag)
+	sc := buildSpellcastingCLI(*class, *level)
 
-		if strings.TrimSpace(c.Equipment.Weapon) != "" {
-			fmt.Printf("Main hand: %s\n", c.Equipment.Weapon)
-		}
-		if strings.TrimSpace(c.Equipment.OffHand) != "" {
-			fmt.Printf("Off hand: %s\n", c.Equipment.OffHand)
+	c := Character{
+		Name:             *name,
+		Race:             strings.ToLower(*race),
+		Class:            strings.ToLower(*class),
+		Level:            *level,
+		Background:       bg,
+		AbilityScores:    final,
+		ProficiencyBonus: profByLevel(*level),
+		Skills:           finalSkills(*class, bg, provided),
+		Spellcasting:     sc,
+	}
+	upsertCharacter(c)
+	saveCharacters()
+	fmt.Printf("saved character %s\n", c.Name)
+}
+
+
+func printEquipmentBlock(c *Character) {
+	if strings.TrimSpace(c.Equipment.Weapon) != "" {
+		fmt.Printf("Main hand: %s\n", c.Equipment.Weapon)
+		if dmg := computeWeaponDamageString(c); dmg != "" {
+			fmt.Printf("Weapon damage: %s\n", dmg)
 		}
-		if strings.TrimSpace(c.Equipment.Armor) != "" {
-			fmt.Printf("Armor: %s\n", c.Equipment.Armor)
+	}
+	if strings.TrimSpace(c.Equipment.OffHand) != "" {
+		fmt.Printf("Off hand: %s\n", c.Equipment.OffHand)
+	}
+	if strings.TrimSpace(c.Equipment.Armor) != "" {
+		fmt.Printf("Armor: %s\n", c.Equipment.Armor)
+	}
+	if strings.TrimSpace(c.Equipment.Shield) != "" {
+		fmt.Printf("Shield: %s\n", c.Equipment.Shield)
+	}
+}
+
+func showHalfOrWarlockSlots(c *Character, minSlot int) {
+	if ck := cantripsKnown(c.Class, c.Level); ck > 0 {
+		fmt.Println(constSpellSlotsLine)
+		fmt.Printf("  Level 0: %d\n", ck)
+	}
+	keys := slotKeys(c, minSlot)
+	if len(keys) > 0 {
+		if cantripsKnown(c.Class, c.Level) == 0 {
+			fmt.Println(constSpellSlotsLine)
 		}
-		if strings.TrimSpace(c.Equipment.Shield) != "" {
-			fmt.Printf("Shield: %s\n", c.Equipment.Shield)
+		printSpellSlotsBlock(c, keys, false)
+	}
+}
+
+func showFullCaster(c *Character, noSlots bool) {
+	if !noSlots {
+		fmt.Println(constSpellSlotsLine)
+		if ck := cantripsKnown(c.Class, c.Level); ck > 0 {
+			fmt.Printf("  Level 0: %d\n", ck)
 		}
+		keys := slotKeys(c, 1)
+		printSpellSlotsBlock(c, keys, false)
+	}
+	sca := spellcastingAbilityForClass(c.Class)
+	if sca != "" {
+		abMod := abilityMod(abilityScoreByName(c, sca))
+		saveDC := 8 + c.ProficiencyBonus + abMod
+		attack := c.ProficiencyBonus + abMod
+		fmt.Printf("Spellcasting ability: %s\n", sca)
+		fmt.Printf("Spell save DC: %d\n", saveDC)
+		fmt.Printf("Spell attack bonus: %+d\n", attack)
+	}
+}
 
-		if c.Spellcasting != nil {
-			switch casterType(c.Class) {
-			case "half":
-				if ck := cantripsKnown(c.Class, c.Level); ck > 0 {
-					fmt.Println("Spell slots:")
-					fmt.Printf("  Level 0: %d\n", ck)
-				}
-				keys := make([]int, 0, len(c.Spellcasting.SlotsByLevel))
-				for lvl := range c.Spellcasting.SlotsByLevel {
-					if lvl >= 1 {
-						keys = append(keys, lvl)
-					}
-				}
-				sort.Ints(keys)
-				if len(keys) > 0 {
-					if cantripsKnown(c.Class, c.Level) == 0 {
-						fmt.Println("Spell slots:")
-					}
-					for _, lvl := range keys {
-						fmt.Printf("  Level %d: %d\n", lvl, c.Spellcasting.SlotsByLevel[lvl])
-					}
-				}
+func printSpellcastingView(c *Character, noSlots bool) {
+	if c.Spellcasting == nil {
+		return
+	}
+	switch casterType(c.Class) {
+	case "half":
+		showHalfOrWarlockSlots(c, 1)
+	case "warlock":
+		showHalfOrWarlockSlots(c, 0)
+	case "full":
+		showFullCaster(c, noSlots)
+	}
+}
 
-			case "warlock":
-				if ck := cantripsKnown(c.Class, c.Level); ck > 0 {
-					fmt.Println("Spell slots:")
-					fmt.Printf("  Level 0: %d\n", ck)
-				}
-				keys := make([]int, 0, len(c.Spellcasting.SlotsByLevel))
-				for lvl := range c.Spellcasting.SlotsByLevel {
-					keys = append(keys, lvl)
-				}
-				sort.Ints(keys)
-				if len(keys) > 0 {
-					if cantripsKnown(c.Class, c.Level) == 0 {
-						fmt.Println("Spell slots:")
-					}
-					for _, lvl := range keys {
-						fmt.Printf("  Level %d: %d\n", lvl, c.Spellcasting.SlotsByLevel[lvl])
-					}
-				}
+func cmdView(args []string) {
+	fs := flag.NewFlagSet("view", flag.ExitOnError)
+	name := fs.String("name", "", "required")
+	noSlots := fs.Bool("no-slots", false, "hide spell slot lines")
+	_ = fs.Parse(args)
 
-			case "full":
-				if !*noSlots {
-					fmt.Println("Spell slots:")
-					if ck := cantripsKnown(c.Class, c.Level); ck > 0 {
-						fmt.Printf("  Level 0: %d\n", ck)
-					}
-					keys := make([]int, 0, len(c.Spellcasting.SlotsByLevel))
-					for lvl := range c.Spellcasting.SlotsByLevel {
-						if lvl >= 1 {
-							keys = append(keys, lvl)
-						}
-					}
-					sort.Ints(keys)
-					for _, lvl := range keys {
-						fmt.Printf("  Level %d: %d\n", lvl, c.Spellcasting.SlotsByLevel[lvl])
-					}
-				}
-				sca := spellcastingAbilityForClass(c.Class)
-				if sca != "" {
-					abMod := abilityMod(abilityScoreByName(c, sca))
-					saveDC := 8 + c.ProficiencyBonus + abMod
-					attack := c.ProficiencyBonus + abMod
-					fmt.Printf("Spellcasting ability: %s\n", sca)
-					fmt.Printf("Spell save DC: %d\n", saveDC)
-					fmt.Printf("Spell attack bonus: %+d\n", attack)
-				}
-			}
-		}
+	c := findCharLike(*name)
+	if c == nil {
+		fmt.Printf(constCharNotFoundFmt, *name)
+		return
+	}
 
-		fmt.Printf("Armor class: %d\n", computeArmorClass(c))
-		fmt.Printf("Initiative bonus: %d\n", computeInitiativeBonus(c))
-		fmt.Printf("Passive perception: %d\n", computePassivePerception(c))
+	fmt.Printf("Name: %s\n", c.Name)
+	fmt.Printf("Class: %s\n", strings.ToLower(c.Class))
+	fmt.Printf("Race: %s\n", strings.ToLower(c.Race))
+	fmt.Printf("Background: %s\n", strings.ToLower(strings.TrimSpace(c.Background)))
+	fmt.Printf("Level: %d\n", c.Level)
 
-		return
+	printAbilityScores(c)
+	fmt.Printf("Proficiency bonus: %+d\n", c.ProficiencyBonus)
 
-	case "list":
-		for _, c := range characters {
-			fmt.Printf("- %s (%s, level %d, %s)\n", c.Name, c.Class, c.Level, c.Race)
-			fmt.Printf("Background: %s  ProficiencyBonus: %d\n", c.Background, c.ProficiencyBonus)
-		}
+	skillsOut := normalizeSkillList(c.Skills)
+	fmt.Printf("Skill proficiencies: %s\n", strings.Join(skillsOut, ", "))
 
-	case "delete":
-		fs := flag.NewFlagSet("delete", flag.ExitOnError)
-		name := fs.String("name", "", "")
-		_ = fs.Parse(os.Args[2:])
-		for i := range characters {
-			if characters[i].Name == *name {
-				characters = append(characters[:i], characters[i+1:]...)
-				saveCharacters()
-				fmt.Printf("deleted %s\n", *name)
-				return
-			}
-		}
-		fmt.Printf("character \"%s\" not found\n", *name)
+	printEquipmentBlock(c)
+	printSpellcastingView(c, *noSlots)
 
-	case "equip":
-		fs := flag.NewFlagSet("equip", flag.ExitOnError)
-		name := fs.String("name", "", "")
-		weapon := fs.String("weapon", "", "")
-		armor := fs.String("armor", "", "")
-		shield := fs.String("shield", "", "")
-		slot := fs.String("slot", "", "")
-		_ = fs.Parse(os.Args[2:])
-
-		c := findCharLike(*name)
-		if c == nil {
-			fmt.Printf("character \"%s\" not found\n", *name)
-			return
-		}
+	fmt.Printf("Armor class: %d\n", computeArmorClass(c))
+	fmt.Printf("Initiative bonus: %d\n", computeInitiativeBonus(c))
+	fmt.Printf("Passive perception: %d\n", computePassivePerception(c))
+}
 
-		s := strings.ToLower(strings.TrimSpace(*slot))
-		if s == "offhand" {
-			s = "off hand"
-		}
-		if s == "mainhand" {
-			s = "main hand"
-		}
 
-		normalize := func(x string) string {
-			return normalizeEquipment(x)
-		}
-		warnUnknown := func(x string) {
-			if x == "" {
-				return
-			}
-			if !isKnownEquipment(x) && equipmentCSVLoaded {
-				fmt.Printf("(warning) \"%s\" not found in equipment CSV; continuing\n", x)
-			}
-		}
+func normalizeSlotName(in string) string {
+	s := strings.ToLower(strings.TrimSpace(in))
+	switch s {
+	case "offhand":
+		return "off hand"
+	case "mainhand":
+		return "main hand"
+	default:
+		return s
+	}
+}
 
-		if *weapon != "" {
-			w := normalize(*weapon)
-			warnUnknown(w)
-			if s == "off hand" {
-				if c.Equipment.OffHand != "" {
-					fmt.Println("off hand already occupied")
-					return
-				}
-				c.Equipment.OffHand = w
-				fmt.Printf("Equipped weapon %s to off hand\n", w)
-			} else {
-				if c.Equipment.Weapon != "" {
-					fmt.Println("main hand already occupied")
-					return
-				}
-				c.Equipment.Weapon = w
-				hand := "main hand"
-				if s != "" && s != "main hand" {
-					hand = s
-				}
-				fmt.Printf("Equipped weapon %s to %s\n", w, hand)
-			}
-		}
-		if *armor != "" {
-			a := normalize(*armor)
-			warnUnknown(a)
-			c.Equipment.Armor = a
-			fmt.Printf("Equipped armor %s\n", a)
-		}
-		if *shield != "" {
-			sh := normalize(*shield)
-			warnUnknown(sh)
-			c.Equipment.Shield = sh
-			fmt.Printf("Equipped shield %s\n", sh)
-		}
-		saveCharacters()
+func warnUnknownIfNeeded(x string) {
+	if x == "" {
+		return
+	}
+	if !isKnownEquipment(x) && equipmentCSVLoaded {
+		fmt.Printf("(warning) \"%s\" not found in equipment CSV; continuing\n", x)
+	}
+}
 
-	case "prepare", "prepare-spell":
-		fs := flag.NewFlagSet("prepare", flag.ExitOnError)
-		name := fs.String("name", "", "required")
-		spell := fs.String("spell", "", "required")
-		_ = fs.Parse(os.Args[2:])
-		if *spell != "" && len(fs.Args()) > 0 {
-			*spell = *spell + " " + strings.Join(fs.Args(), " ")
-		}
-		if *name == "" || *spell == "" {
-			usage()
-			return
-		}
+func equipWeapon(c *Character, weapon, slot string) bool {
+	if weapon == "" {
+		return false
+	}
+	w := normalizeEquipment(weapon)
+	warnUnknownIfNeeded(w)
+	if slot == "off hand" {
+		if c.Equipment.OffHand != "" {
+			fmt.Println("off hand already occupied")
+			return true
+		}
+		c.Equipment.OffHand = w
+		fmt.Printf("Equipped weapon %s to off hand\n", w)
+		return true
+	}
+	if c.Equipment.Weapon != "" {
+		fmt.Println("main hand already occupied")
+		return true
+	}
+	c.Equipment.Weapon = w
+	hand := "main hand"
+	if slot != "" && slot != "main hand" {
+		hand = slot
+	}
+	fmt.Printf("Equipped weapon %s to %s\n", w, hand)
+	return true
+}
 
-		c := findCharLike(*name)
-		if c == nil {
-			fmt.Printf("character \"%s\" not found\n", *name)
-			return
-		}
-		if casterType(c.Class) == "none" {
-			fmt.Println("this class can't cast spells")
-			return
-		}
-		if learnsSpells(c.Class) && !preparesSpells(c.Class) {
-			fmt.Println("this class learns spells and can't prepare them")
-			return
-		}
+func equipArmor(c *Character, armor string) bool {
+	if armor == "" {
+		return false
+	}
+	a := normalizeEquipment(armor)
+	warnUnknownIfNeeded(a)
+	c.Equipment.Armor = a
+	fmt.Printf("Equipped armor %s\n", a)
+	return true
+}
 
-		sp := strings.ToLower(strings.TrimSpace(*spell))
-		slots := spellSlotsFor(casterType(c.Class), c.Level)
-		maxSlot := 0
-		for lvl := range slots {
-			if lvl > maxSlot {
-				maxSlot = lvl
-			}
-		}
+func equipShield(c *Character, shield string) bool {
+	if shield == "" {
+		return false
+	}
+	sh := normalizeEquipment(shield)
+	warnUnknownIfNeeded(sh)
+	c.Equipment.Shield = sh
+	fmt.Printf("Equipped shield %s\n", sh)
+	return true
+}
 
-		if spellLvl, ok := spellLevelByName(sp); ok {
-			if maxSlot == 0 || spellLvl > maxSlot {
-				fmt.Println("the spell has higher level than the available spell slots")
-				return
-			}
-		} else {
-			fmt.Println("the spell has higher level than the available spell slots")
-			return
-		}
+func cmdEquip(args []string) {
+	fs := flag.NewFlagSet("equip", flag.ExitOnError)
+	name := fs.String("name", "", "")
+	weapon := fs.String("weapon", "", "")
+	armor := fs.String("armor", "", "")
+	shield := fs.String("shield", "", "")
+	slot := fs.String("slot", "", "")
+	_ = fs.Parse(args)
+
+	c := findCharLike(*name)
+	if c == nil {
+		fmt.Printf(constCharNotFoundFmt, *name)
+		return
+	}
 
-		if c.Spellcasting == nil {
-			c.Spellcasting = &Spellcasting{SlotsByLevel: map[int]int{}, Spells: []Spell{}}
-		}
-		found := false
-		for i := range c.Spellcasting.Spells {
-			if strings.ToLower(c.Spellcasting.Spells[i].Name) == sp {
-				c.Spellcasting.Spells[i].Prepared = true
-				found = true
-				break
-			}
-		}
-		if !found {
-			lvl, _ := spellLevelByName(sp)
-			c.Spellcasting.Spells = append(c.Spellcasting.Spells, Spell{Name: sp, Level: lvl, Prepared: true})
-		}
+	s := normalizeSlotName(*slot)
+	changed := false
+	if equipWeapon(c, *weapon, s) {
+		changed = true
+	}
+	if equipArmor(c, *armor) {
+		changed = true
+	}
+	if equipShield(c, *shield) {
+		changed = true
+	}
+	if changed {
 		saveCharacters()
-		fmt.Printf("Prepared spell %s\n", sp)
+	}
+}
 
-	case "learn", "learn-spell":
-		fs := flag.NewFlagSet("learn", flag.ExitOnError)
-		name := fs.String("name", "", "required")
-		spell := fs.String("spell", "", "required")
-		_ = fs.Parse(os.Args[2:])
 
-		if *spell != "" && len(fs.Args()) > 0 {
-			*spell = *spell + " " + strings.Join(fs.Args(), " ")
-		}
-		if *name == "" || *spell == "" {
-			usage()
-			return
-		}
+func mergeSpellArgs(spellFlag string, rest []string) string {
+	if spellFlag != "" && len(rest) > 0 {
+		return spellFlag + " " + strings.Join(rest, " ")
+	}
+	return spellFlag
+}
 
-		ch := findCharLike(*name)
-		if ch == nil {
-			fmt.Printf("character \"%s\" not found\n", *name)
-			return
-		}
-		if casterType(ch.Class) == "none" {
-			fmt.Println("this class can't cast spells")
-			return
-		}
-		if preparesSpells(ch.Class) {
-			fmt.Println("this class prepares spells and can't learn them")
-			return
-		}
+func validatePrepareInputs(name, spell string) bool {
+	if name == "" || spell == "" {
+		usage()
+		return false
+	}
+	return true
+}
 
-		target := strings.ToLower(strings.TrimSpace(*spell))
-		slots := spellSlotsFor(casterType(ch.Class), ch.Level)
-		maxSlot := 0
-		for lvl := range slots {
-			if lvl > maxSlot {
-				maxSlot = lvl
-			}
+func ensureCanPrepare(c *Character) bool {
+	if c == nil {
+		return false
+	}
+	if casterType(c.Class) == "none" {
+		fmt.Println("this class can't cast spells")
+		return false
+	}
+	if learnsSpells(c.Class) && !preparesSpells(c.Class) {
+		fmt.Println("this class learns spells and can't prepare them")
+		return false
+	}
+	return true
+}
+
+func spellWithinSlotsOrError(c *Character, target string) (int, bool) {
+	slots := spellSlotsFor(casterType(c.Class), c.Level)
+	if spellLvl, ok := spellLevelByName(target); ok {
+		if max := maxSlotLevel(slots); max == 0 || spellLvl > max {
+			fmt.Println(constSpellTooHighMsg)
+			return 0, false
 		}
+		return spellLvl, true
+	}
+	fmt.Println(constSpellTooHighMsg)
+	return 0, false
+}
 
-		if spellLvl, ok := spellLevelByName(target); ok {
-			if maxSlot == 0 || spellLvl > maxSlot {
-				fmt.Println("the spell has higher level than the available spell slots")
-				return
-			}
-		} else {
-			fmt.Println("the spell has higher level than the available spell slots")
+func setPrepared(c *Character, target string, lvl int) {
+	if c.Spellcasting == nil {
+		c.Spellcasting = &Spellcasting{SlotsByLevel: map[int]int{}, Spells: []Spell{}}
+	}
+	for i := range c.Spellcasting.Spells {
+		if strings.ToLower(c.Spellcasting.Spells[i].Name) == target {
+			c.Spellcasting.Spells[i].Prepared = true
+			saveCharacters()
+			fmt.Printf("Prepared spell %s\n", target)
 			return
 		}
+	}
+	c.Spellcasting.Spells = append(c.Spellcasting.Spells, Spell{Name: target, Level: lvl, Prepared: true})
+	saveCharacters()
+	fmt.Printf("Prepared spell %s\n", target)
+}
 
-		if ch.Spellcasting == nil {
-			ch.Spellcasting = &Spellcasting{SlotsByLevel: map[int]int{}, Spells: []Spell{}}
-		}
-		for _, s := range ch.Spellcasting.Spells {
-			if strings.ToLower(s.Name) == target {
-				saveCharacters()
-				fmt.Printf("Learned spell %s\n", target)
-				return
-			}
-		}
-		lvl, _ := spellLevelByName(target)
-		ch.Spellcasting.Spells = append(ch.Spellcasting.Spells, Spell{
-			Name:     target,
-			Level:    lvl,
-			Prepared: false,
-		})
-		saveCharacters()
-		fmt.Printf("Learned spell %s\n", target)
+func cmdPrepare(args []string) {
+	fs := flag.NewFlagSet("prepare", flag.ExitOnError)
+	name := fs.String("name", "", "required")
+	spell := fs.String("spell", "", "required")
+	_ = fs.Parse(args)
 
-	case "enrich":
-		fs := flag.NewFlagSet("enrich", flag.ExitOnError)
-		limit := fs.Int("limit", 0, "")
-		dryrun := fs.Bool("dryrun", false, "")
-		rps := fs.Int("rps", 6, "")
-		workers := fs.Int("workers", 8, "number of concurrent workers")
-		_ = fs.Parse(os.Args[2:])
-
-		var tick <-chan time.Time
-		var ticker *time.Ticker
-		if *rps > 0 {
-			interval := time.Second / time.Duration(*rps)
-			if interval <= 0 {
-				interval = time.Second
-			}
-			ticker = time.NewTicker(interval)
-			defer ticker.Stop()
-			tick = ticker.C
-		}
+	merged := mergeSpellArgs(*spell, fs.Args())
+	if !validatePrepareInputs(*name, merged) {
+		return
+	}
 
-		type task struct {
-			url, kind  string
-			cIdx, sIdx int
-		}
-		type weaponResult struct {
-			cIdx int
-			ok   bool
-			cat  string
-			rng  int
-			two  bool
-		}
-		type armorResult struct {
-			cIdx int
-			ok   bool
-			base int
-			dex  bool
-			max  *int
-		}
-		type spellResult struct {
-			cIdx, sIdx  int
-			ok          bool
-			school, rng string
-		}
+	c := findCharLike(*name)
+	if !ensureCanPrepare(c) {
+		return
+	}
 
-		jobs := make(chan task, 64)
-		wres := make(chan weaponResult, 256)
-		ares := make(chan armorResult, 256)
-		sres := make(chan spellResult, 256)
+	target := strings.ToLower(strings.TrimSpace(merged))
+	lvl, ok := spellWithinSlotsOrError(c, target)
+	if !ok {
+		return
+	}
+	setPrepared(c, target, lvl)
+}
 
-		var wg sync.WaitGroup
-		if *workers <= 0 {
-			*workers = 8
-		}
-		for i := 0; i < *workers; i++ {
-			wg.Add(1)
-			go func() {
-				defer wg.Done()
-				for t := range jobs {
-					switch t.kind {
-					case "weapon":
-						var eq apiEquipment
-						if err := httpGetJSON(t.url, &eq, tick); err != nil {
-							wres <- weaponResult{cIdx: t.cIdx, ok: false}
-							continue
-						}
-						two := false
-						for _, p := range eq.Properties {
-							pi := strings.ToLower(p.Index + " " + p.Name)
-							if strings.Contains(pi, "two-handed") {
-								two = true
-								break
-							}
-						}
-						wres <- weaponResult{cIdx: t.cIdx, ok: true, cat: eq.EquipmentCategory.Name, rng: eq.Range.Normal, two: two}
-
-					case "armor":
-						var eq apiEquipment
-						if err := httpGetJSON(t.url, &eq, tick); err != nil {
-							ares <- armorResult{cIdx: t.cIdx, ok: false}
-							continue
-						}
-						ares <- armorResult{cIdx: t.cIdx, ok: true, base: eq.ArmorClass.Base, dex: eq.ArmorClass.DexBonus, max: eq.ArmorClass.MaxBonus}
-
-					case "spell":
-						var sp apiSpell
-						if err := httpGetJSON(t.url, &sp, tick); err != nil {
-							sres <- spellResult{cIdx: t.cIdx, sIdx: t.sIdx, ok: false}
-							continue
-						}
-						sres <- spellResult{cIdx: t.cIdx, sIdx: t.sIdx, ok: true, school: sp.School.Name, rng: sp.Range}
-					}
-				}
-			}()
-		}
 
-		var total int
-		processedChars := 0
-		for ci := range characters {
-			if *limit > 0 && processedChars >= *limit {
-				break
-			}
-			ch := &characters[ci]
-			if w := strings.TrimSpace(ch.Equipment.Weapon); w != "" {
-				total++
-				jobs <- task{url: "https://www.dnd5eapi.co/api/equipment/" + slugify(w), kind: "weapon", cIdx: ci}
-			}
-			if a := strings.TrimSpace(ch.Equipment.Armor); a != "" {
-				total++
-				jobs <- task{url: "https://www.dnd5eapi.co/api/equipment/" + slugify(a), kind: "armor", cIdx: ci}
-			}
-			if ch.Spellcasting != nil {
-				for si := range ch.Spellcasting.Spells {
-					total++
-					jobs <- task{url: "https://www.dnd5eapi.co/api/spells/" + slugify(ch.Spellcasting.Spells[si].Name), kind: "spell", cIdx: ci, sIdx: si}
-				}
-			}
-			processedChars++
+func cmdList() {
+	for _, c := range characters {
+		fmt.Printf("- %s (%s, level %d, %s)\n", c.Name, c.Class, c.Level, c.Race)
+		fmt.Printf("Background: %s  ProficiencyBonus: %d\n", c.Background, c.ProficiencyBonus)
+	}
+}
+
+func cmdDelete(args []string) {
+	fs := flag.NewFlagSet("delete", flag.ExitOnError)
+	name := fs.String("name", "", "")
+	_ = fs.Parse(args)
+	for i := range characters {
+		if characters[i].Name == *name {
+			characters = append(characters[:i], characters[i+1:]...)
+			saveCharacters()
+			fmt.Printf("deleted %s\n", *name)
+			return
 		}
-		close(jobs)
-
-		go func() { wg.Wait(); close(wres); close(ares); close(sres) }()
-
-		done := 0
-		for done < total {
-			select {
-			case wr, ok := <-wres:
-				if ok {
-					if wr.ok {
-						characters[wr.cIdx].Equipment.WeaponInfo.Category = wr.cat
-						characters[wr.cIdx].Equipment.WeaponInfo.RangeNormal = wr.rng
-						characters[wr.cIdx].Equipment.WeaponInfo.TwoHanded = wr.two
-					}
-					done++
-				}
-			case ar, ok := <-ares:
-				if ok {
-					if ar.ok {
-						characters[ar.cIdx].Equipment.ArmorInfo.ArmorClass = ar.base
-						characters[ar.cIdx].Equipment.ArmorInfo.DexBonus = ar.dex
-						characters[ar.cIdx].Equipment.ArmorInfo.MaxDexBonus = ar.max
-					}
-					done++
-				}
-			case sr, ok := <-sres:
-				if ok {
-					if sr.ok && characters[sr.cIdx].Spellcasting != nil &&
-						sr.sIdx >= 0 && sr.sIdx < len(characters[sr.cIdx].Spellcasting.Spells) {
-						characters[sr.cIdx].Spellcasting.Spells[sr.sIdx].School = sr.school
-						characters[sr.cIdx].Spellcasting.Spells[sr.sIdx].Range = sr.rng
-					}
-					done++
-				}
-			}
+	}
+	fmt.Printf(constCharNotFoundFmt, *name)
+}
+
+func cmdLearn(args []string) {
+	fs := flag.NewFlagSet("learn", flag.ExitOnError)
+	name := fs.String("name", "", "required")
+	spell := fs.String("spell", "", "required")
+	_ = fs.Parse(args)
+
+	if *spell != "" && len(fs.Args()) > 0 {
+		*spell = *spell + " " + strings.Join(fs.Args(), " ")
+	}
+	if *name == "" || *spell == "" {
+		usage()
+		return
+	}
+
+	ch := findCharLike(*name)
+	if ch == nil {
+		fmt.Printf(constCharNotFoundFmt, *name)
+		return
+	}
+	if casterType(ch.Class) == "none" {
+		fmt.Println("this class can't cast spells")
+		return
+	}
+	if preparesSpells(ch.Class) {
+		fmt.Println("this class prepares spells and can't learn them")
+		return
+	}
+
+	target := strings.ToLower(strings.TrimSpace(*spell))
+	slots := spellSlotsFor(casterType(ch.Class), ch.Level)
+	if spellLvl, ok := spellLevelByName(target); ok {
+		if max := maxSlotLevel(slots); max == 0 || spellLvl > max {
+			fmt.Println(constSpellTooHighMsg)
+			return
 		}
+	} else {
+		fmt.Println(constSpellTooHighMsg)
+		return
+	}
 
-		if !*dryrun {
+	if ch.Spellcasting == nil {
+		ch.Spellcasting = &Spellcasting{SlotsByLevel: map[int]int{}, Spells: []Spell{}}
+	}
+	for _, s := range ch.Spellcasting.Spells {
+		if strings.ToLower(s.Name) == target {
 			saveCharacters()
+			fmt.Printf("Learned spell %s\n", target)
+			return
 		}
-		fmt.Println("enrichment done")
+	}
+	lvl, _ := spellLevelByName(target)
+	ch.Spellcasting.Spells = append(ch.Spellcasting.Spells, Spell{
+		Name:     target,
+		Level:    lvl,
+		Prepared: false,
+	})
+	saveCharacters()
+	fmt.Printf("Learned spell %s\n", target)
+}
 
-	case "inspect":
-		fs := flag.NewFlagSet("inspect", flag.ExitOnError)
-		name := fs.String("name", "", "optional: name or substring")
-		_ = fs.Parse(os.Args[2:])
-		showChar := func(c *Character) {
-			fmt.Printf("== %s ==\n", c.Name)
-			if strings.TrimSpace(c.Equipment.Weapon) != "" {
-				wi := c.Equipment.WeaponInfo
-				fmt.Printf("Weapon: %s\n", c.Equipment.Weapon)
-				if wi.Category != "" || wi.RangeNormal != 0 || wi.TwoHanded {
-					fmt.Printf("  category=%s, range.normal=%d, two-handed=%t\n", wi.Category, wi.RangeNormal, wi.TwoHanded)
-				} else {
-					fmt.Println("  (no enriched weapon data)")
-				}
+func cmdEnrich(args []string) {
+	fs := flag.NewFlagSet("enrich", flag.ExitOnError)
+	limit := fs.Int("limit", 0, "")
+	_ = fs.Parse(args)
+
+	processed := 0
+	for i := range characters {
+		if *limit > 0 && processed >= *limit {
+			break
+		}
+		EnrichCharacter(&characters[i])
+		processed++
+	}
+	saveCharacters()
+	fmt.Println("enrichment done")
+}
+
+func cmdInspect(args []string) {
+	fs := flag.NewFlagSet("inspect", flag.ExitOnError)
+	name := fs.String("name", "", "optional: name or substring")
+	_ = fs.Parse(args)
+
+	showChar := func(c *Character) {
+		fmt.Printf("== %s ==\n", c.Name)
+		if strings.TrimSpace(c.Equipment.Weapon) != "" {
+			wi := c.Equipment.WeaponInfo
+			fmt.Printf("Weapon: %s\n", c.Equipment.Weapon)
+			if wi.Category != "" || wi.RangeNormal != 0 || wi.TwoHanded {
+				fmt.Printf("  category=%s, range.normal=%d, two-handed=%t\n", wi.Category, wi.RangeNormal, wi.TwoHanded)
+			} else {
+				fmt.Println("  (no enriched weapon data)")
 			}
-			if strings.TrimSpace(c.Equipment.Armor) != "" {
-				ai := c.Equipment.ArmorInfo
-				fmt.Printf("Armor: %s\n", c.Equipment.Armor)
-				if ai.ArmorClass != 0 || ai.DexBonus || ai.MaxDexBonus != nil {
-					if ai.MaxDexBonus != nil {
-						fmt.Printf("  armor_class=%d, dex_bonus=%t, max_dex_bonus=%d\n", ai.ArmorClass, ai.DexBonus, *ai.MaxDexBonus)
-					} else {
-						fmt.Printf("  armor_class=%d, dex_bonus=%t\n", ai.ArmorClass, ai.DexBonus)
-					}
+		}
+		if strings.TrimSpace(c.Equipment.Armor) != "" {
+			ai := c.Equipment.ArmorInfo
+			fmt.Printf("Armor: %s\n", c.Equipment.Armor)
+			if ai.ArmorClass != 0 || ai.DexBonus || ai.MaxDexBonus != nil {
+				if ai.MaxDexBonus != nil {
+					fmt.Printf("  armor_class=%d, dex_bonus=%t, max_dex_bonus=%d\n", ai.ArmorClass, ai.DexBonus, *ai.MaxDexBonus)
 				} else {
-					fmt.Println("  (no enriched armor data)")
+					fmt.Printf("  armor_class=%d, dex_bonus=%t\n", ai.ArmorClass, ai.DexBonus)
 				}
+			} else {
+				fmt.Println("  (no enriched armor data)")
 			}
-			if c.Spellcasting != nil && len(c.Spellcasting.Spells) > 0 {
-				any := false
-				for _, s := range c.Spellcasting.Spells {
-					if s.School != "" || s.Range != "" {
-						if !any {
-							fmt.Println("Spells (enriched):")
-							any = true
-						}
-						fmt.Printf("  - %s: school=%s, range=%s\n", s.Name, s.School, s.Range)
+		}
+		if c.Spellcasting != nil && len(c.Spellcasting.Spells) > 0 {
+			any := false
+			for _, s := range c.Spellcasting.Spells {
+				if s.School != "" || s.Range != "" {
+					if !any {
+						fmt.Println("Spells (enriched):")
+						any = true
 					}
-				}
-				if !any {
-					fmt.Println("Spells: (no enriched spell data)")
+					fmt.Printf("  - %s: school=%s, range=%s\n", s.Name, s.School, s.Range)
 				}
 			}
-			fmt.Println()
-		}
-		if strings.TrimSpace(*name) == "" {
-			for i := range characters {
-				showChar(&characters[i])
+			if !any {
+				fmt.Println("Spells: (no enriched spell data)")
 			}
-			return
 		}
+		fmt.Println()
+	}
 
-		c := findCharLike(*name)
-		if c == nil {
-			fmt.Printf("character \"%s\" not found\n", *name)
-			return
+	if strings.TrimSpace(*name) == "" {
+		for i := range characters {
+			showChar(&characters[i])
 		}
-		showChar(c)
+		return
+	}
+	c := findCharLike(*name)
+	if c == nil {
+		fmt.Printf(constCharNotFoundFmt, *name)
+
+		return
+	}
+	showChar(c)
+}
 
+/**
+* main is the CLI entrypoint for creating, viewing, managing, and enriching characters
+**/
+func main() {
+	loadCharacters()
+	if len(os.Args) < 2 {
+		usage()
+		os.Exit(1)
+	}
+	switch os.Args[1] {
+	case "serve":
+		serveCommand(os.Args[2:])
+	case "create":
+		cmdCreate(os.Args[2:])
+	case "view":
+		cmdView(os.Args[2:])
+	case "list":
+		cmdList()
+	case "delete":
+		cmdDelete(os.Args[2:])
+	case "equip":
+		cmdEquip(os.Args[2:])
+	case "prepare", "prepare-spell":
+		cmdPrepare(os.Args[2:])
+	case "learn", "learn-spell":
+		cmdLearn(os.Args[2:])
+	case "enrich":
+		cmdEnrich(os.Args[2:])
+	case "inspect":
+		cmdInspect(os.Args[2:])
 	default:
 		usage()
 		os.Exit(2)
 	}
-}
\ No newline at end of file
+}
diff --git a/server.go b/server.go
index c78800e..8a0c59a 100644
--- a/server.go
+++ b/server.go
@@ -1,3 +1,5 @@
+// Layer: Infrastructure / UI (HTTP transport/controller layer)
+
 package main
 
 import (
@@ -37,94 +39,104 @@ func writeJSON(w http.ResponseWriter, status int, v any) {
 	_ = json.NewEncoder(w).Encode(v)
 }
 
+/* --------- kleine helpers om complexiteit te verlagen (gedrag ongewijzigd) --------- */
+
+func handleCharactersGet(w http.ResponseWriter, r *http.Request) {
+	name := strings.TrimSpace(r.URL.Query().Get("name"))
+	if name == "" {
+		writeJSON(w, http.StatusOK, characters)
+		return
+	}
+	if c := findCharLike(name); c != nil {
+		writeJSON(w, http.StatusOK, c)
+		return
+	}
+	writeJSON(w, http.StatusNotFound, apiError{Error: "character not found"})
+}
+
+func handleCharactersPost(w http.ResponseWriter, r *http.Request) {
+	var req createRequest
+	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
+		writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid json"})
+		return
+	}
+	req.Name = strings.TrimSpace(req.Name)
+	if req.Name == "" {
+		writeJSON(w, http.StatusBadRequest, apiError{Error: "name is required"})
+		return
+	}
+	if req.Level < 1 {
+		req.Level = 1
+	}
+
+	c := buildCharacterFromRequest(req)
+
+	// upsert (exact hetzelfde als voorheen)
+	idx := -1
+	for i := range characters {
+		if strings.EqualFold(characters[i].Name, c.Name) {
+			idx = i
+			break
+		}
+	}
+	if idx >= 0 {
+		characters[idx] = c
+	} else {
+		characters = append(characters, c)
+	}
+
+	EnrichCharacter(&c)
+
+	saveCharacters()
+	writeJSON(w, http.StatusCreated, c)
+}
+
 /**
 *  apiCharactersHandler handles GET and POST requests for /api/characters
 **/
 func apiCharactersHandler(w http.ResponseWriter, r *http.Request) {
 	switch r.Method {
 	case http.MethodGet:
-		name := strings.TrimSpace(r.URL.Query().Get("name"))
-		if name == "" {
-			writeJSON(w, http.StatusOK, characters)
-			return
-		}
-		if c := findCharLike(name); c != nil {
-			writeJSON(w, http.StatusOK, c)
-			return
-		}
-		writeJSON(w, http.StatusNotFound, apiError{Error: "character not found"})
+		handleCharactersGet(w, r)
 		return
-
 	case http.MethodPost:
-		var req createRequest
-		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
-			writeJSON(w, http.StatusBadRequest, apiError{Error: "invalid json"})
-			return
-		}
-		req.Name = strings.TrimSpace(req.Name)
-		if req.Name == "" {
-			writeJSON(w, http.StatusBadRequest, apiError{Error: "name is required"})
-			return
-		}
-		if req.Level < 1 {
-			req.Level = 1
-		}
-
-		c := buildCharacterFromRequest(req)
-
-		idx := -1
-		for i := range characters {
-			if strings.EqualFold(characters[i].Name, c.Name) {
-				idx = i
-				break
-			}
-		}
-		if idx >= 0 {
-			characters[idx] = c
-		} else {
-			characters = append(characters, c)
-		}
-
-		EnrichCharacter(&c)
-
-		saveCharacters()
-		writeJSON(w, http.StatusCreated, c)
+		handleCharactersPost(w, r)
 		return
-
 	default:
 		w.Header().Set("Allow", "GET, POST")
 		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
 	}
 }
 
-/**
-*  buildCharacterFromRequest constructs a Character struct from an API request
-**/
-func buildCharacterFromRequest(req createRequest) Character {
-	var base AbilityScores
+// --- Helpers to reduce cognitive complexity (behavior unchanged) ---
+
+func baseScoresFromReq(req createRequest) AbilityScores {
 	if req.AbilityScores == nil {
-		base = assignStandardArray()
-	} else {
-		s := *req.AbilityScores
-		all := s.Strength > 0 && s.Dexterity > 0 && s.Constitution > 0 &&
-			s.Intelligence > 0 && s.Wisdom > 0 && s.Charisma > 0
-		if all {
-			base = s
-		} else {
-			nz10 := func(x int) int { if x == 0 { return 10 }; return x }
-			base = AbilityScores{
-				Strength:     nz10(s.Strength),
-				Dexterity:    nz10(s.Dexterity),
-				Constitution: nz10(s.Constitution),
-				Intelligence: nz10(s.Intelligence),
-				Wisdom:       nz10(s.Wisdom),
-				Charisma:     nz10(s.Charisma),
-			}
-		}
+		return assignStandardArray()
 	}
+	s := *req.AbilityScores
+	all := s.Strength > 0 && s.Dexterity > 0 && s.Constitution > 0 &&
+		s.Intelligence > 0 && s.Wisdom > 0 && s.Charisma > 0
+	if all {
+		return s
+	}
+	nz10 := func(x int) int {
+		if x == 0 { return 10 }
+		return x
+	}
+	return AbilityScores{
+		Strength:     nz10(s.Strength),
+		Dexterity:    nz10(s.Dexterity),
+		Constitution: nz10(s.Constitution),
+		Intelligence: nz10(s.Intelligence),
+		Wisdom:       nz10(s.Wisdom),
+		Charisma:     nz10(s.Charisma),
+	}
+}
 
-	rStr, rDex, rCon, rInt, rWis, rCha := raceBonusDeltas(req.Race)
-	final := AbilityScores{
+func applyRaceBonusesTo(base AbilityScores, race string) AbilityScores {
+	rStr, rDex, rCon, rInt, rWis, rCha := raceBonusDeltas(race)
+	return AbilityScores{
 		Strength:     base.Strength + rStr,
 		Dexterity:    base.Dexterity + rDex,
 		Constitution: base.Constitution + rCon,
@@ -132,26 +144,44 @@ func buildCharacterFromRequest(req createRequest) Character {
 		Wisdom:       base.Wisdom + rWis,
 		Charisma:     base.Charisma + rCha,
 	}
+}
 
-	bg := "acolyte"
+func deriveSkillsFor(req createRequest, bg string) []string {
+	if len(req.Skills) == 0 {
+		// zelfde fallback als voorheen
+		return finalSkills(req.Class, bg, nil)
+	}
 	var skills []string
-	if len(req.Skills) > 0 {
-		for _, s := range req.Skills {
-			if t := strings.TrimSpace(s); t != "" {
-				skills = append(skills, normalizeSkill(t))
-			}
+	for _, s := range req.Skills {
+		if t := strings.TrimSpace(s); t != "" {
+			skills = append(skills, normalizeSkill(t))
 		}
-	} else {
-		skills = finalSkills(req.Class, bg, nil)
 	}
+	return skills
+}
 
-	var sc *Spellcasting
-	if ct := casterType(req.Class); ct != "none" {
-		slots := spellSlotsFor(ct, req.Level)
-		maxL := maxSpellLevel(ct, req.Level)
-		spells := pickSpellsForClass(req.Class, maxL, 4)
-		sc = &Spellcasting{SlotsByLevel: slots, Spells: spells}
+func buildSpellcastingFor(class string, level int) *Spellcasting {
+	if ct := casterType(class); ct != "none" {
+		slots := spellSlotsFor(ct, level)
+		maxL := maxSpellLevel(ct, level)
+		spells := pickSpellsForClass(class, maxL, 4)
+		return &Spellcasting{SlotsByLevel: slots, Spells: spells}
 	}
+	return nil
+}
+
+// --- Refactored function (same behavior, lower complexity) ---
+
+/**
+*  buildCharacterFromRequest constructs a Character struct from an API request
+**/
+func buildCharacterFromRequest(req createRequest) Character {
+	base := baseScoresFromReq(req)
+	final := applyRaceBonusesTo(base, req.Race)
+
+	bg := "acolyte"
+	skills := deriveSkillsFor(req, bg)
+	sc := buildSpellcastingFor(req.Class, req.Level)
 
 	return Character{
 		Name:             req.Name,
@@ -187,7 +217,7 @@ func startServer(addr string) error {
 }
 
 /**
-*  serveCommand parses CLI args and starts the API server
+*  serveCommand parses CLI args and starts the HTTP server
 **/
 func serveCommand(args []string) {
 	fs := flag.NewFlagSet("serve", flag.ExitOnError)
@@ -197,4 +227,4 @@ func serveCommand(args []string) {
 		fmt.Fprintln(os.Stderr, err)
 		os.Exit(1)
 	}
-}
\ No newline at end of file
+}
diff --git a/skills.go b/skills.go
index 1d1975a..af633d9 100644
--- a/skills.go
+++ b/skills.go
@@ -1,3 +1,5 @@
+// Layer: Domain (business rules: skills/proficiencies; no IO)
+
 package main
 
 import (
diff --git a/storage.go b/storage.go
index f5a7e94..71bacac 100644
--- a/storage.go
+++ b/storage.go
@@ -1,8 +1,12 @@
+// Layer: Infrastructure (persistence adapter: read/write characters.json)
+
 package main
 
 import (
 	"encoding/json"
 	"os"
+	"strings"
+
 )
 
 var characters []Character
@@ -25,4 +29,22 @@ func loadCharacters() {
 func saveCharacters() {
 	data, _ := json.MarshalIndent(characters, "", "  ")
 	_ = os.WriteFile(dbFile, data, 0644)
-}
\ No newline at end of file
+}
+
+func findCharLike(name string) *Character {
+	q := strings.ToLower(strings.TrimSpace(name))
+	if q == "" {
+		return nil
+	}
+	for i := range characters {
+		if strings.EqualFold(characters[i].Name, name) {
+			return &characters[i]
+		}
+	}
+	for i := range characters {
+		if strings.Contains(strings.ToLower(characters[i].Name), q) {
+			return &characters[i]
+		}
+	}
+	return nil
+}
diff --git a/types.go b/types.go
index b623d75..dc3c321 100644
--- a/types.go
+++ b/types.go
@@ -1,3 +1,5 @@
+// Layer: Domain 
+
 package main
 
 var StandardArray = []int{15, 14, 13, 12, 10, 8}
@@ -46,6 +48,9 @@ type WeaponMeta struct {
 	Category    string
 	RangeNormal int
 	TwoHanded   bool
+	DamageDice  string
+	Finesse     bool
+	WeaponRange string
 }
 
 type ArmorMeta struct {
diff --git a/utils.go b/utils.go
index b511eee..f5a0d42 100644
--- a/utils.go
+++ b/utils.go
@@ -1,7 +1,10 @@
+// Layer: Domain 
+
 package main
 
 import "strings"
 
+
 /**
 *  profByLevel returns SRD proficiency bonus for the given level
 **/
@@ -100,19 +103,6 @@ func slugify(s string) string {
 	return s
 }
 
-/**
-*  findCharLike finds a character by case-insensitive exact or substring match
-**/
-func findCharLike(name string) *Character {
-	lc := strings.ToLower(strings.TrimSpace(name))
-	for i := range characters {
-		if strings.ToLower(characters[i].Name) == lc || strings.Contains(strings.ToLower(characters[i].Name), lc) {
-			return &characters[i]
-		}
-	}
-	return nil
-}
-
 /**
 *  abilityScoreByName returns a character's score by short name (str/dex/...)
 **/
